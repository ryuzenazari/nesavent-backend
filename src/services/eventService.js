const Event = require('../models/Event');const WaitingList = require('../models/WaitingList');const Refund = require('../models/Refund');const Ticket = require('../models/Ticket');const logger = require('../utils/logger');const createEvent = async (eventData, creatorId) => {  try {    const event = new Event({      ...eventData,      creator: creatorId    });    await event.save();    return event;  } catch (error) {    logger.error('Error creating event:', error);    throw error;  }};const enableEarlyBird = async (eventId, ticketTypeId, earlyBirdData) => {  try {    const event = await Event.findById(eventId);    if (!event) {      throw new Error('Event tidak ditemukan');    }    const ticketType = event.ticketTypes.id(ticketTypeId);    if (!ticketType) {      throw new Error('Tipe tiket tidak ditemukan');    }    ticketType.earlyBirdPrice = earlyBirdData.price;    ticketType.earlyBirdEndDate = earlyBirdData.endDate;    ticketType.isEarlyBirdActive = true;    await event.save();    return event;  } catch (error) {    logger.error('Error enabling early bird:', error);    throw error;  }};const addPromoCode = async (eventId, promoCodeData) => {  try {    const event = await Event.findById(eventId);    if (!event) {      throw new Error('Event tidak ditemukan');    }    event.promoCodes.push(promoCodeData);    await event.save();    return event;  } catch (error) {    logger.error('Error adding promo code:', error);    throw error;  }};const enableWaitingList = async (eventId, maxCapacity) => {  try {    const event = await Event.findById(eventId);    if (!event) {      throw new Error('Event tidak ditemukan');    }    event.waitingList = {      isEnabled: true,      maxCapacity,      currentCount: 0    };    await event.save();    return event;  } catch (error) {    logger.error('Error enabling waiting list:', error);    throw error;  }};const addToWaitingList = async (eventId, userId, ticketType, quantity) => {  try {    const event = await Event.findById(eventId);    if (!event) {      throw new Error('Event tidak ditemukan');    }    if (!event.waitingList.isEnabled) {      throw new Error('Waiting list tidak diaktifkan untuk event ini');    }    if (event.waitingList.currentCount >= event.waitingList.maxCapacity) {      throw new Error('Waiting list sudah penuh');    }    const isAlreadyInList = await WaitingList.isUserInWaitingList(eventId, userId);    if (isAlreadyInList) {      throw new Error('Anda sudah terdaftar dalam waiting list');    }    const position = await WaitingList.getNextPosition(eventId);    const expiresAt = new Date();    expiresAt.setDate(expiresAt.getDate() + 7);    const waitingListEntry = new WaitingList({      event: eventId,      user: userId,      ticketType,      quantity,      position,      expiresAt    });    await waitingListEntry.save();    event.waitingList.currentCount += 1;    await event.save();    return waitingListEntry;  } catch (error) {    logger.error('Error adding to waiting list:', error);    throw error;  }};const setupRecurringEvent = async (eventId, recurringData) => {  try {    const event = await Event.findById(eventId);    if (!event) {      throw new Error('Event tidak ditemukan');    }    event.isRecurring = true;    event.recurringPattern = recurringData.pattern;    event.recurringEndDate = recurringData.endDate;    await event.save();    return event;  } catch (error) {    logger.error('Error setting up recurring event:', error);    throw error;  }};const setupRefundPolicy = async (eventId, refundPolicyData) => {  try {    const event = await Event.findById(eventId);    if (!event) {      throw new Error('Event tidak ditemukan');    }    event.refundPolicy = {      isEnabled: true,      allowedUntil: refundPolicyData.allowedUntil,      refundPercentage: refundPolicyData.refundPercentage,      processingFee: refundPolicyData.processingFee    };    await event.save();    return event;  } catch (error) {    logger.error('Error setting up refund policy:', error);    throw error;  }};const processRefund = async (ticketId, userId, refundData) => {  try {    const isAllowed = await Refund.isRefundAllowed(ticketId);    if (!isAllowed) {      throw new Error('Refund tidak diizinkan untuk tiket ini');    }    const refundAmounts = await Refund.calculateRefundAmount(ticketId);    const ticket = await Ticket.findById(ticketId).populate('event');    const refund = new Refund({      ticket: ticketId,      event: ticket.event._id,      user: userId,      ticketPrice: refundAmounts.ticketPrice,      refundAmount: refundAmounts.refundAmount,      reason: refundData.reason,      paymentMethod: refundData.paymentMethod,      bankAccount: refundData.bankAccount    });    await refund.save();    return refund;  } catch (error) {    logger.error('Error processing refund:', error);    throw error;  }};const approveRefund = async (refundId, adminId, adminNote) => {  try {    const refund = await Refund.findById(refundId);    if (!refund) {      throw new Error('Refund tidak ditemukan');    }    refund.status = 'approved';    refund.adminNote = adminNote;    refund.processedBy = adminId;    refund.processedAt = new Date();    await refund.save();    const ticket = await Ticket.findById(refund.ticket);    ticket.status = 'refunded';    await ticket.save();    return refund;  } catch (error) {    logger.error('Error approving refund:', error);    throw error;  }};module.exports = {  createEvent,  enableEarlyBird,  addPromoCode,  enableWaitingList,  addToWaitingList,  setupRecurringEvent,  setupRefundPolicy,  processRefund,  approveRefund};