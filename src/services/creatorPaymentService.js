const CreatorPayment = require('../models/CreatorPayment');const Event = require('../models/Event');const Ticket = require('../models/Ticket');const logger = require('../utils/logger');const createPayment = async (eventId, creatorId, paymentData) => {  try {    const event = await Event.findById(eventId);    if (!event) {      throw new Error('Event tidak ditemukan');    }    const tickets = await Ticket.find({      event: eventId,      status: 'used',      paymentStatus: 'paid'    });    const totalAmount = tickets.reduce((sum, ticket) => sum + ticket.price, 0);    const payment = new CreatorPayment({      creator: creatorId,      event: eventId,      amount: totalAmount,      paymentMethod: paymentData.paymentMethod,      bankAccount: paymentData.bankAccount,      eWallet: paymentData.eWallet    });    await payment.save();    return payment;  } catch (error) {    logger.error('Error creating creator payment:', error);    throw error;  }};const processPayment = async (paymentId, adminId, paymentProof, notes) => {  try {    const payment = await CreatorPayment.findById(paymentId);    if (!payment) {      throw new Error('Pembayaran tidak ditemukan');    }    payment.status = 'processing';    payment.paymentProof = paymentProof;    payment.notes = notes;    payment.processedBy = adminId;    payment.processedAt = new Date();    await payment.save();    return payment;  } catch (error) {    logger.error('Error processing creator payment:', error);    throw error;  }};const completePayment = async (paymentId, adminId) => {  try {    const payment = await CreatorPayment.findById(paymentId);    if (!payment) {      throw new Error('Pembayaran tidak ditemukan');    }    payment.status = 'completed';    payment.processedBy = adminId;    payment.processedAt = new Date();    await payment.save();    return payment;  } catch (error) {    logger.error('Error completing creator payment:', error);    throw error;  }};const getCreatorPaymentHistory = async (creatorId, page = 1, limit = 10) => {  try {    return await CreatorPayment.getCreatorPaymentHistory(creatorId, page, limit);  } catch (error) {    logger.error('Error getting creator payment history:', error);    throw error;  }};const getPendingPayments = async creatorId => {  try {    const result = await CreatorPayment.getPendingPayments(creatorId);    return (      result[0] || {        totalAmount: 0,        count: 0      }    );  } catch (error) {    logger.error('Error getting pending payments:', error);    throw error;  }};const getPaymentsToProcess = async (page = 1, limit = 10) => {  try {    const skip = (page - 1) * limit;    const payments = await CreatorPayment.find({      status: {        $in: ['pending', 'processing']      }    })      .sort({        createdAt: 1      })      .skip(skip)      .limit(limit)      .populate('creator', 'name email')      .populate('event', 'title startDate');    const total = await CreatorPayment.countDocuments({      status: {        $in: ['pending', 'processing']      }    });    return {      payments,      total,      page,      totalPages: Math.ceil(total / limit)    };  } catch (error) {    logger.error('Error getting payments to process:', error);    throw error;  }};module.exports = {  createPayment,  processPayment,  completePayment,  getCreatorPaymentHistory,  getPendingPayments,  getPaymentsToProcess};